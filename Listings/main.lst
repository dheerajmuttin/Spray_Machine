C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Library\Devi
                    -ce\Include;.\Library\StdDriver\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "MS51_32K.h"
   2          #include "definations.h"
   3          #include "PWM.h"
   4          
   5          sbit MT_Forword_Switch  = P2^5;
   6          sbit MT_Reverse_Switch = P1^5;
   7          
   8          enum HCSR04_STAGE Sensor_1 = NOP;
   9          enum HCSR04_STAGE Sensor_2 = NOP;
  10          
  11          TRAVEL Cart;
  12          char chart_status = CYCLE_COMP;
  13          unsigned int PWM0_Periode;
  14          unsigned int PWM1_Periode;
  15          unsigned int MOTOR_SPEED=0;
  16          unsigned int PUMP_SPEED=0;
  17          unsigned char Pump_status = OFF;
  18          unsigned char Forword_Switch_Status = RELESE;
  19          unsigned char Reverse_Swith_Status = RELESE;
  20          
  21          unsigned char Water_Level;
  22          unsigned int Distance;
  23          unsigned char display_vlaue[3]={0x00,0x00,0x00};
  24          unsigned char High_Byte,Low_Byte;
  25          unsigned int Word;
  26          float Echo_Time;
  27          
  28          char Pre_FWD_Status = RELESE;
  29          char Pre_RVS_Status = RELESE;
  30          
  31          
  32          void main()
  33          {
  34   1        MODIFY_HIRC(HIRC_24);
  35   1        Reset_Travel_Staus(&Cart);
  36   1        PWM0_Periode = Initialise_PWM(1);
  37   1        PWM1_Periode = Initialise_PWM1(1);
  38   1        UART0_Timer3(115200);
  39   1        Initilisation();
  40   1        
  41   1        while(1)
  42   1        {
  43   2          Get_Motor_Speed();
  44   2          Get_Pump_Speed();
  45   2          
  46   2      /*    if (Cart.Start != CYCLE_ON)
  47   2          {
  48   2            if(Reverse_Swith == 0 && Reverse_Swith_Status == RELESE)
  49   2            {
  50   2              Reverse_Dir;
  51   2              PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
  52   2              Reverse_Swith_Status = PRESS;
  53   2            }
  54   2            else if(Reverse_Swith == 1 && Reverse_Swith_Status == PRESS)
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 2   

  55   2            {
  56   2              PWM_Disable(2);
  57   2              Reverse_Swith_Status = RELESE;
  58   2            }
  59   2            else if(Forword_Switch == 0 && Forword_Switch_Status == RELESE)
  60   2            {
  61   2              Forword_Dir;
  62   2              PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
  63   2              Forword_Switch_Status = PRESS;
  64   2            }
  65   2          
  66   2            else if(Forword_Switch == 0 && Forword_Switch_Status == PRESS)
  67   2            {
  68   2              PWM_Disable(2);
  69   2              Forword_Switch_Status = RELESE;
  70   2            }
  71   2          }
  72   2          */
  73   2          
  74   2          if (chart_status/*Cart.Start*/ == CYCLE_ON)
  75   2          {
  76   3            if(Cart.Direction == FORWORD && Cart.End_Sensor == 1)
  77   3            {
  78   4              PWM_Disable(2);
  79   4              Timer0_Delay(SYS_FREQ,1000,1000);
  80   4              Cart.Direction = REVERSE;
  81   4              Reverse_Dir;
  82   4              PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
  83   4            }
  84   3            if(Cart.Direction == REVERSE && Cart.Start_Sensor == 1)
  85   3            {
  86   4              PWM_Disable(2);
  87   4              PWM1_Disable(1);
  88   4              Cart.Direction = FORWORD;
  89   4              Cart.Start_Sensor = 0;
  90   4              Cart.End_Sensor = 0;
  91   4              //Cart.Start = CYCLE_COMP;
  92   4              chart_status = CYCLE_COMP;
  93   4              
  94   4            }
  95   3          }
  96   2          
  97   2          if (Sensor_1 == COMPLETE)
  98   2          {
  99   3            // calculate time distance and hight of water using paramters 
 100   3            Sensor_1 = NOP;
 101   3          }
 102   2          
 103   2            if (Sensor_2 == COMPLETE)
 104   2          {
 105   3            // calculate time distance and hight of water using paramters 
 106   3            SFRS = 0;
 107   3            Low_Byte = C1L;
 108   3            High_Byte = C1H;
 109   3            Word = MAKEWORD(High_Byte,Low_Byte);
 110   3            Echo_Time = (float)Word * Time_Constant;
 111   3            Distance = Echo_Time/58;
 112   3            Sensor_2 = NOP;
 113   3            Update_Display(1,Water_Level);
 114   3          }
 115   2          
 116   2          if(MT_Forword_Switch == PRESS && Pre_FWD_Status == RELESE && MT_Reverse_Switch == RELESE)
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 3   

 117   2          {
 118   3            Pre_FWD_Status = PRESS;
 119   3            Forword_Dir;
 120   3            PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
 121   3          }
 122   2          if (MT_Forword_Switch == RELESE && Pre_FWD_Status == PRESS && MT_Reverse_Switch == RELESE)
 123   2          {
 124   3            Pre_FWD_Status = RELESE;
 125   3            PWM_Disable(2);
 126   3          }
 127   2            if(MT_Forword_Switch == RELESE && Pre_RVS_Status == RELESE && MT_Reverse_Switch == PRESS)
 128   2          {
 129   3            Pre_RVS_Status = PRESS;
 130   3            Forword_Dir;
 131   3            PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
 132   3          }
 133   2          if (MT_Forword_Switch == RELESE && Pre_RVS_Status == PRESS && MT_Reverse_Switch == RELESE)
 134   2          {
 135   3            Pre_RVS_Status = RELESE;
 136   3            Reverse_Dir;
 137   3            PWM_Disable(2);
 138   3          }
 139   2          
 140   2          if (MT_Forword_Switch == RELESE && MT_Reverse_Switch == RELESE)
 141   2          {
 142   3            PWM_Disable(2);
 143   3          }
 144   2        }//while end
 145   1      }// main end 
 146          
 147          void Initilisation()
 148          {
 149   1        P13_PUSHPULL_MODE; // dir switch
 150   1        clr_P1_3;
 151   1        P03_INPUT_MODE; // proxy 1
 152   1        P04_INPUT_MODE; // proxy 2
 153   1        P30_INPUT_MODE; // switch 1 INT0  external intrrupt emergency stop switch
 154   1        P05_INPUT_MODE; //proxy 3
 155   1        P01_INPUT_MODE; //proxy 4
 156   1        P15_INPUT_MODE; //switch 5 pin change interrupt
 157   1        P25_INPUT_MODE; // swtich 4 pin change interrupt
 158   1        P36_INPUT_MODE; // swtich 2 pin change interrupt
 159   1        P37_INPUT_MODE; // swtich 3 pin change interrupt
 160   1        P32_INPUT_MODE;// swtich 6 pin change interrupt
 161   1        P13_PUSHPULL_MODE; // buzzer outpute
 162   1        clr_P1_3; // clear the buzzer outpute
 163   1        P11_PUSHPULL_MODE; // trigger 1
 164   1        P10_PUSHPULL_MODE; // trigger 2
 165   1        clr_P1_1; // clear the trigger 1
 166   1        clr_P0_0; // clear the trigger 2
 167   1        
 168   1        INT0_FALLING_EDGE_TRIG;
 169   1        ENABLE_INT0_INTERRUPT; // emergency stop button on interrupt external switch 1
 170   1        //ENABLE_TIMER2_INTERRUPT; // timer2 overflow detection for sensor checking
 171   1        //ENABLE_CAPTURE_INTERRUPT; // capture interrupt detection
 172   1        //ENABLE_WKT_INTERRUPT; // wakeup timer interrupt for the time counting
 173   1        ENABLE_PIT0_P03_FALLINGEDGE; // enable the pin interrupt 0 on the P03 pin; proxy 1
 174   1        ENABLE_PIT1_P04_FALLINGEDGE;// enable the pin interrupt 1 on the P04 pin; proxy 2
 175   1        ENABLE_PIT2_P36_FALLINGEDGE;// enable the pin interrupt 2 on the P36 pin; switch 2; on pin 9
 176   1        ENABLE_PIT3_P37_FALLINGEDGE;//enable the pin interrupt 3 on the P37 pin; switch 3; on pin 10
 177   1        ENABLE_PIN_INTERRUPT; //  pinchange interrupt for button pressed 
 178   1        
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 4   

 179   1        // timer 2 initialization divide by 4 timer
 180   1        //clr_T2CON_CMRL2;
 181   1        TIMER2_DIV_4; // 24/4=6MHZ frequency
 182   1        //clr_T2MOD_LDEN;
 183   1        IC0_P12_CAP0_BOTHEDGE_CAPTURE;//echo 1
 184   1        IC3_P00_CAP1_BOTHEDGE_CAPTURE; // echo 2 both edge capture
 185   1        //set_T2MOD_CAPCR;
 186   1        set_EIE_ECAP;
 187   1        ENABLE_GLOBAL_INTERRUPT; // globle interrupt enable pin
 188   1      }
 189          
 190          
 191          
 192          void trigger_1()
 193          {
 194   1        // 10us high pin trigger 
 195   1        set_P1_1;
 196   1        Timer0_Delay(SYS_FREQ,1,100);
 197   1        Sensor_1 = TRIGGERED;
 198   1        Sensor_2 = NOP;
 199   1        // and set the status byte enum data type 
 200   1        //set reset timer to apropriate ccp module in t2mod last bits
 201   1      }
 202          
 203          void trigger_2()
 204          {
 205   1        // 10us high pin trigger 
 206   1        set_P1_0;
 207   1        Timer0_Delay(SYS_FREQ,1,100);
 208   1        clr_P1_0;
 209   1        Sensor_2 = TRIGGERED;
 210   1        Sensor_1 = NOP;
 211   1        // and set the status byte enum data type 
 212   1        //set reset timer to apropriate ccp module in t2mod last bits
 213   1      }
 214          void Reset_Travel_Staus(TRAVEL *Cart)
 215          {
 216   1        Cart->Start = CYCLE_COMP;
 217   1        Cart->Direction = FORWORD;
 218   1        Cart->Start_Sensor = 0;
 219   1        Cart->End_Sensor = 0;
 220   1      }
 221          
 222          void Get_Motor_Speed()
 223            
 224          {
 225   1        unsigned int Current_speed = 0;
 226   1        unsigned int ADC_reding = 0;
 227   1        ENABLE_ADC_CH12;
 228   1        clr_ADCCON0_ADCF;
 229   1        set_ADCCON0_ADCS;                  // ADC start trig signal
 230   1        while(ADCF == 0);
 231   1        ADC_reding =(ADCRH<<4)+(ADCRL&0x0F);
 232   1        //Current_speed = (int)map_1(ADC_reding,0,4095,0,100);
 233   1        Current_speed = map(ADC_reding,0,4095,0,100);
 234   1        
 235   1        if (Current_speed != MOTOR_SPEED )
 236   1        {
 237   2          MOTOR_SPEED = Current_speed;
 238   2          Update_Display(2,MOTOR_SPEED);
 239   2        }
 240   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 5   

 241          
 242          void Get_Pump_Speed()
 243          {
 244   1        unsigned int Current_speed1 = 0;
 245   1        unsigned int ADC_reding = 0;
 246   1        ENABLE_ADC_CH9;
 247   1        clr_ADCCON0_ADCF;
 248   1        set_ADCCON0_ADCS;                  // ADC start trig signal
 249   1        while(ADCF == 0);
 250   1        ADC_reding =(ADCRH<<4)+(ADCRL&0x0F);
 251   1        //Current_speed1 = (int)map_1(ADC_reding,0,4095,0,100);
 252   1        
 253   1        Current_speed1 = (int)map(ADC_reding,0,4095,0,100);
 254   1        if (Current_speed1 != PUMP_SPEED)
 255   1        {
 256   2          MOTOR_SPEED = Current_speed1;
 257   2          if (Pump_status == ON)
 258   2          {
 259   3            PWM1_Enable(1,PUMP_SPEED,PWM1_Periode);
 260   3            Update_Display(3,PUMP_SPEED);
 261   3          }
 262   2        }
 263   1      }
 264          
 265          
 266          void Update_Display(unsigned char channel,unsigned char value)
 267          {
 268   1        char i;
 269   1        switch (channel)
 270   1        {
 271   2          case 1:
 272   2          display_vlaue[0] = value;
 273   2          break;
 274   2          case 2:
 275   2          display_vlaue[1] = value;
 276   2          break;
 277   2          case 3:
 278   2          display_vlaue[2] = value;
 279   2        }
 280   1        
 281   1        for(i=0;i<3;i++) //  sending to uart remote diplay for showing the status
 282   1        {
 283   2                TI=0;
 284   2                SBUF = display_vlaue[i];
 285   2                while(!TI);
 286   2        }
 287   1        
 288   1      }
 289          
 290          void UART0_Timer3(unsigned long u32Baudrate)
 291          {
 292   1                  SCON = 0x50;          //UART0 Mode1,REN=1,TI=1
 293   1                  set_PCON_SMOD;        //UART0 Double Rate Enable
 294   1                  T3CON &= 0xF8;        //T3PS2=0,T3PS1=0,T3PS0=0(Prescale=1)
 295   1                  set_T3CON_BRCK;        //UART0 baud rate clock source = Timer3
 296   1                  RH3   = HIBYTE(65536 - (SYS_FREQ / 16 / u32Baudrate));
 297   1                  RL3   = LOBYTE(65536 - (SYS_FREQ / 16 / u32Baudrate));
 298   1                  set_T3CON_TR3;         //Trigger Timer3
 299   1                  clr_IE_ES;
 300   1      }
 301          
 302          
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 6   

 303          void INT0_ISR(void) interrupt 0          // Vector @  0x03
 304          {
 305   1        DISABLE_GLOBAL_INTERRUPT;
 306   1          _push_(SFRS);
 307   1        //emergency stop button function written
 308   1          PWM_Disable_int(2);
 309   1          PWM1_Disable_int(1);
 310   1          //Cart.Start = CYCLE_STOP;
 311   1            chart_status = CYCLE_STOP;
 312   1        
 313   1        // set all the satus regarding direction 
 314   1        // and emergency stop is detected then start cycle from previous memory status
 315   1          clr_TCON_IE0;
 316   1          _pop_(SFRS);
 317   1        ENABLE_GLOBAL_INTERRUPT;
 318   1      }
 319          
 320          void Pin_INT_ISR(void) interrupt 7       // Vector @  0x3B
 321          {
 322   1        unsigned char temp;
 323   1        DISABLE_GLOBAL_INTERRUPT;
 324   1        _push_(SFRS);
 325   1        temp = PIF;
 326   1        if(temp&SET_BIT0)
 327   1        {
 328   2          // proxy 1 Sensor Detection
 329   2          //if(Cart.Start == CYCLE_ON)
 330   2            if(chart_status == CYCLE_ON)
 331   2          {
 332   3          Cart.Start_Sensor = 1;
 333   3          }
 334   2        }
 335   1        
 336   1        temp = PIF;
 337   1        if(temp&SET_BIT1)
 338   1        {
 339   2          //if(Cart.Start == CYCLE_ON)
 340   2            if(chart_status == CYCLE_ON)
 341   2          {
 342   3           // proxy 2 Sensor Detection
 343   3          Cart.End_Sensor = 1;
 344   3          }
 345   2            
 346   2        }
 347   1        
 348   1        temp = PIF;
 349   1        if(temp&SET_BIT2)
 350   1        {
 351   2          // switch 2 action defination start button cycle
 352   2          if(Cart.Start != CYCLE_ON)
 353   2          {
 354   3            if(Cart.Direction == FORWORD)
 355   3            {
 356   4              Forword_Dir;
 357   4              //Cart.Direction = FORWORD;
 358   4            }
 359   3            {
 360   4              Reverse_Dir;
 361   4              //Cart.Direction = REVERSE;
 362   4            }
 363   3            PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
 364   3            //Cart.Start = 0x0  CYCLE_ON;
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 7   

 365   3            chart_status = 0x00;
 366   3            Pump_status = ON; // manual checking status of pump cleared when pump status is on
 367   3            PWM1_Enable_int(1,PUMP_SPEED,PWM1_Periode);
 368   3          }
 369   2        }
 370   1        
 371   1        temp = PIF;
 372   1        if(temp&SET_BIT3)
 373   1        {
 374   2          if(Pump_status != ON)
 375   2          {
 376   3            PWM1_Enable_int(1,PUMP_SPEED,PWM1_Periode);
 377   3            Pump_status = ON;
 378   3          }
 379   2          
 380   2          else
 381   2          {
 382   3            PWM1_Disable_int(1);
 383   3            Pump_status = OFF;
 384   3          }
 385   2          
 386   2          // switch 3 action defination   pump start stop manully 
 387   2        }
 388   1           PIF = 0x00;
 389   1          _pop_(SFRS);
 390   1        ENABLE_GLOBAL_INTERRUPT;
 391   1      }
 392          
 393          
 394          
 395          void Capture_ISR(void) interrupt 12      // Vector @  0x63
 396          {
 397   1        unsigned char temp;
 398   1        DISABLE_GLOBAL_INTERRUPT;
 399   1          _push_(SFRS);
 400   1            SFRS=0;
 401   1        temp = CAPCON0;
 402   1        if(temp&SET_BIT0)
 403   1        {
 404   2          if(Sensor_1 == TRIGGERED)
 405   2          {
 406   3            Sensor_1 = CAPTURED;
 407   3            C0L = 0x00;
 408   3            C0H = 0x00;
 409   3          }
 410   2          if(Sensor_1 == CAPTURED)
 411   2          {
 412   3            Sensor_1 = COMPLETE;
 413   3            clr_T2CON_TR2; // stope the timer2 from counting
 414   3          }
 415   2        }
 416   1        temp = CAPCON0;
 417   1        if(temp&SET_BIT1)
 418   1        {
 419   2          if(Sensor_2 == TRIGGERED)
 420   2          {
 421   3            Sensor_2 = CAPTURED;
 422   3            C0L = 0x00;
 423   3            C0H = 0x00;
 424   3          }
 425   2          if(Sensor_2 == CAPTURED)
 426   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              09/10/2021 01:18:19 PAGE 8   

 427   3            Sensor_2 = COMPLETE;
 428   3            clr_T2CON_TR2; // stope the timer2 from counting
 429   3          }
 430   2        }
 431   1          clr_CAPCON0_CAPF0;
 432   1          clr_CAPCON0_CAPF1;
 433   1          _pop_(SFRS);
 434   1        ENABLE_GLOBAL_INTERRUPT;
 435   1      }
 436          
 437          void Timer1_ISR(void) interrupt 3        // Vector @  0x1B
 438          {
 439   1          _push_(SFRS);
 440   1         clr_TCON_TF1;
 441   1          _pop_(SFRS);
 442   1          _pop_(SFRS);
 443   1      }
 444          
 445          void WKT_ISR(void) interrupt 17                 // Vector @  0x8B
 446          {
 447   1          _push_(SFRS);
 448   1          clr_WKCON_WKTF;
 449   1          _pop_(SFRS);
 450   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1769    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     35       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
