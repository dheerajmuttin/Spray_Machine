C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Library\Devi
                    -ce\Include;.\Library\StdDriver\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "MS51_32K.h"
   2          #include "definations.h"
   3          #include "PWM.h"
   4          
   5          sbit MT_Forword_Switch  = P2^5;
   6          sbit MT_Reverse_Switch = P1^5;
   7          
   8          enum HCSR04_STAGE Sensor_1 = NOP;
   9          enum HCSR04_STAGE Sensor_2 = NOP;
  10          
  11          TRAVEL Cart;
  12          char chart_status = CYCLE_COMP;
  13          unsigned int PWM0_Periode;
  14          unsigned int PWM1_Periode;
  15          unsigned int MOTOR_SPEED=0;
  16          unsigned int PUMP_SPEED=0;
  17          unsigned char Pump_status = OFF;
  18          unsigned char Forword_Switch_Status = RELESE;
  19          unsigned char Reverse_Swith_Status = RELESE;
  20          
  21          unsigned char Water_Level;
  22          unsigned int Distance;
  23          unsigned char display_vlaue[3]={0x00,0x00,0x00};
  24          unsigned char High_Byte,Low_Byte;
  25          unsigned int Word;
  26          float Echo_Time;
  27          
  28          char Pre_FWD_Status = RELESE;
  29          char Pre_RVS_Status = RELESE;
  30          
  31          
  32          void main()
  33          {
  34   1        MODIFY_HIRC(HIRC_24);
  35   1        Reset_Travel_Staus(&Cart);
  36   1        PWM0_Periode = Initialise_PWM(1);
  37   1        PWM1_Periode = Initialise_PWM1(1);
  38   1        UART0_Timer3(115200);
  39   1        Initilisation();
  40   1        
  41   1        while(1)
  42   1        {
  43   2          Get_Motor_Speed();
  44   2          Get_Pump_Speed();
  45   2          
  46   2      /*    if (Cart.Start != CYCLE_ON)
  47   2          {
  48   2            if(Reverse_Swith == 0 && Reverse_Swith_Status == RELESE)
  49   2            {
  50   2              Reverse_Dir;
  51   2              PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
  52   2              Reverse_Swith_Status = PRESS;
  53   2            }
  54   2            else if(Reverse_Swith == 1 && Reverse_Swith_Status == PRESS)
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 2   

  55   2            {
  56   2              PWM_Disable(2);
  57   2              Reverse_Swith_Status = RELESE;
  58   2            }
  59   2            else if(Forword_Switch == 0 && Forword_Switch_Status == RELESE)
  60   2            {
  61   2              Forword_Dir;
  62   2              PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
  63   2              Forword_Switch_Status = PRESS;
  64   2            }
  65   2          
  66   2            else if(Forword_Switch == 0 && Forword_Switch_Status == PRESS)
  67   2            {
  68   2              PWM_Disable(2);
  69   2              Forword_Switch_Status = RELESE;
  70   2            }
  71   2          }
  72   2          */
  73   2          
  74   2          if (chart_status/*Cart.Start*/ == CYCLE_ON)
  75   2          {
  76   3            if(Cart.Direction == FORWORD && Cart.End_Sensor == 1)
  77   3            {
  78   4              PWM_Disable(2);
  79   4              Timer0_Delay(SYS_FREQ,1000,1000);
  80   4              Cart.Direction = REVERSE;
  81   4              Reverse_Dir;
  82   4              PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
  83   4            }
  84   3            if(Cart.Direction == REVERSE && Cart.Start_Sensor == 1)
  85   3            {
  86   4              PWM_Disable(2);
  87   4              PWM1_Disable(1);
  88   4              Cart.Direction = FORWORD;
  89   4              Cart.Start_Sensor = 0;
  90   4              Cart.End_Sensor = 0;
  91   4              //Cart.Start = CYCLE_COMP;
  92   4              chart_status = CYCLE_COMP;
  93   4              
  94   4            }
  95   3          }
  96   2          
  97   2          if (Sensor_1 == COMPLETE)
  98   2          {
  99   3            // calculate time distance and hight of water using paramters 
 100   3            Sensor_1 = NOP;
 101   3          }
 102   2          
 103   2            if (Sensor_2 == COMPLETE)
 104   2          {
 105   3            // calculate time distance and hight of water using paramters 
 106   3            SFRS = 0;
 107   3            Low_Byte = C1L;
 108   3            High_Byte = C1H;
 109   3            Word = MAKEWORD(High_Byte,Low_Byte);
 110   3            Echo_Time = (float)Word * Time_Constant;
 111   3            Distance = Echo_Time/58;
 112   3            Sensor_2 = NOP;
 113   3            Update_Display(1,Water_Level);
 114   3          }
 115   2          
 116   2          if(MT_Forword_Switch == PRESS && Pre_FWD_Status == RELESE && MT_Reverse_Switch == RELESE)
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 3   

 117   2          {
 118   3            Pre_FWD_Status = PRESS;
 119   3            Forword_Dir;
 120   3            PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
 121   3          }
 122   2          if (MT_Forword_Switch == RELESE && Pre_FWD_Status == PRESS && MT_Reverse_Switch == RELESE)
 123   2          {
 124   3            Pre_FWD_Status = RELESE;
 125   3            PWM_Disable(2);
 126   3          }
 127   2            if(MT_Forword_Switch == RELESE && Pre_RVS_Status == RELESE && MT_Reverse_Switch == PRESS)
 128   2          {
 129   3            Pre_RVS_Status = PRESS;
 130   3            Forword_Dir;
 131   3            PWM_Enable(2,MOTOR_SPEED,PWM0_Periode);
 132   3          }
 133   2          if (MT_Forword_Switch == RELESE && Pre_RVS_Status == PRESS && MT_Reverse_Switch == RELESE)
 134   2          {
 135   3            Pre_RVS_Status = RELESE;
 136   3            Reverse_Dir;
 137   3            PWM_Disable(2);
 138   3          }
 139   2          
 140   2          if (MT_Forword_Switch == RELESE && MT_Reverse_Switch == RELESE)
 141   2          {
 142   3            PWM_Disable(2);
 143   3          }
 144   2        }//while end
 145   1      }// main end 
 146          
 147          void Initilisation()
 148          {
 149   1        P13_PUSHPULL_MODE; // dir switch
 150   1        clr_P1_3;
 151   1        P03_INPUT_MODE; // proxy 1
 152   1        P04_INPUT_MODE; // proxy 2
 153   1        P30_INPUT_MODE; // switch 1 INT0  external intrrupt emergency stop switch
 154   1        P05_INPUT_MODE; //proxy 3
 155   1        P01_INPUT_MODE; //proxy 4
 156   1        P15_INPUT_MODE; //switch 5 pin change interrupt
 157   1        P25_INPUT_MODE; // swtich 4 pin change interrupt
 158   1        P36_INPUT_MODE; // swtich 2 pin change interrupt
 159   1        P37_INPUT_MODE; // swtich 3 pin change interrupt
 160   1        P32_INPUT_MODE;// swtich 6 pin change interrupt
 161   1        P13_PUSHPULL_MODE; // buzzer outpute
 162   1        clr_P1_3; // clear the buzzer outpute
 163   1        P11_PUSHPULL_MODE; // trigger 1
 164   1        P10_PUSHPULL_MODE; // trigger 2
 165   1        clr_P1_1; // clear the trigger 1
 166   1        clr_P0_0; // clear the trigger 2
 167   1        
 168   1        INT0_FALLING_EDGE_TRIG;
 169   1        ENABLE_INT0_INTERRUPT; // emergency stop button on interrupt external switch 1
 170   1        //ENABLE_TIMER2_INTERRUPT; // timer2 overflow detection for sensor checking
 171   1        //ENABLE_CAPTURE_INTERRUPT; // capture interrupt detection
 172   1        //ENABLE_WKT_INTERRUPT; // wakeup timer interrupt for the time counting
 173   1        ENABLE_PIT0_P03_FALLINGEDGE; // enable the pin interrupt 0 on the P03 pin; proxy 1
 174   1        ENABLE_PIT1_P04_FALLINGEDGE;// enable the pin interrupt 1 on the P04 pin; proxy 2
 175   1        ENABLE_PIT2_P36_FALLINGEDGE;// enable the pin interrupt 2 on the P36 pin; switch 2;
 176   1        ENABLE_PIT3_P37_FALLINGEDGE;//enable the pin interrupt 3 on the P37 pin; switch 3;
 177   1        ENABLE_PIN_INTERRUPT; //  pinchange interrupt for button pressed 
 178   1        
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 4   

 179   1        // timer 2 initialization divide by 4 timer
 180   1        clr_T2CON_CMRL2;
 181   1        TIMER2_DIV_4; // 24/4=6MHZ frequency
 182   1        clr_T2MOD_LDEN;
 183   1        IC0_P12_CAP0_BOTHEDGE_CAPTURE;//echo 1
 184   1        IC3_P00_CAP1_BOTHEDGE_CAPTURE; // echo 2 both edge capture
 185   1        set_T2MOD_CAPCR;
 186   1        ENABLE_GLOBAL_INTERRUPT; // globle interrupt enable pin
 187   1      }
 188          
 189          
 190          
 191          void trigger_1()
 192          {
 193   1        // 10us high pin trigger 
 194   1        set_P1_1;
 195   1        Timer0_Delay(SYS_FREQ,1,100);
 196   1        Sensor_1 = TRIGGERED;
 197   1        Sensor_2 = NOP;
 198   1        // and set the status byte enum data type 
 199   1        //set reset timer to apropriate ccp module in t2mod last bits
 200   1      }
 201          
 202          void trigger_2()
 203          {
 204   1        // 10us high pin trigger 
 205   1        set_P1_0;
 206   1        Timer0_Delay(SYS_FREQ,1,100);
 207   1        clr_P1_0;
 208   1        Sensor_2 = TRIGGERED;
 209   1        Sensor_1 = NOP;
 210   1        // and set the status byte enum data type 
 211   1        //set reset timer to apropriate ccp module in t2mod last bits
 212   1      }
 213          void Reset_Travel_Staus(TRAVEL *Cart)
 214          {
 215   1        Cart->Start = CYCLE_COMP;
 216   1        Cart->Direction = FORWORD;
 217   1        Cart->Start_Sensor = 0;
 218   1        Cart->End_Sensor = 0;
 219   1      }
 220          
 221          void Get_Motor_Speed()
 222            
 223          {
 224   1        unsigned int Current_speed = 0;
 225   1        unsigned int ADC_reding = 0;
 226   1        ENABLE_ADC_CH12;
 227   1        clr_ADCCON0_ADCF;
 228   1        set_ADCCON0_ADCS;                  // ADC start trig signal
 229   1        while(ADCF == 0);
 230   1        ADC_reding =(ADCRH<<4)|(ADCRL&0x0F);
 231   1        //Current_speed = (int)map_1(ADC_reding,0,4095,0,100);
 232   1        Current_speed = map(ADC_reding,0,4095,0,100);
 233   1        
 234   1        if (Current_speed != MOTOR_SPEED )
 235   1        {
 236   2          MOTOR_SPEED = Current_speed;
 237   2          Update_Display(2,MOTOR_SPEED);
 238   2        }
 239   1      }
 240          
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 5   

 241          void Get_Pump_Speed()
 242          {
 243   1        unsigned int Current_speed1 = 0;
 244   1        unsigned int ADC_reding = 0;
 245   1        ENABLE_ADC_CH9;
 246   1        clr_ADCCON0_ADCF;
 247   1        set_ADCCON0_ADCS;                  // ADC start trig signal
 248   1        while(ADCF == 0);
 249   1        ADC_reding =(ADCRH<<4)|(ADCRL&0x0F);
 250   1        //Current_speed1 = (int)map_1(ADC_reding,0,4095,0,100);
 251   1        
 252   1        Current_speed1 = (int)map(ADC_reding,0,4095,0,100);
 253   1        if (Current_speed1 != PUMP_SPEED)
 254   1        {
 255   2          MOTOR_SPEED = Current_speed1;
 256   2          if (Pump_status == ON)
 257   2          {
 258   3            PWM1_Enable(1,PUMP_SPEED,PWM1_Periode);
 259   3            Update_Display(3,PUMP_SPEED);
 260   3          }
 261   2        }
 262   1      }
 263          
 264          
 265          void Update_Display(unsigned char channel,unsigned char value)
 266          {
 267   1        char i;
 268   1        switch (channel)
 269   1        {
 270   2          case 1:
 271   2          display_vlaue[0] = value;
 272   2          break;
 273   2          case 2:
 274   2          display_vlaue[1] = value;
 275   2          break;
 276   2          case 3:
 277   2          display_vlaue[2] = value;
 278   2        }
 279   1        
 280   1        for(i=0;i<3;i++) //  sending to uart remote diplay for showing the status
 281   1        {
 282   2                TI=0;
 283   2                SBUF = display_vlaue[i];
 284   2                while(!TI);
 285   2        }
 286   1        
 287   1      }
 288          
 289          void UART0_Timer3(unsigned long u32Baudrate)
 290          {
 291   1                  SCON = 0x50;          //UART0 Mode1,REN=1,TI=1
 292   1                  set_PCON_SMOD;        //UART0 Double Rate Enable
 293   1                  T3CON &= 0xF8;        //T3PS2=0,T3PS1=0,T3PS0=0(Prescale=1)
 294   1                  set_T3CON_BRCK;        //UART0 baud rate clock source = Timer3
 295   1                  RH3   = HIBYTE(65536 - (SYS_FREQ / 16 / u32Baudrate));
 296   1                  RL3   = LOBYTE(65536 - (SYS_FREQ / 16 / u32Baudrate));
 297   1                  set_T3CON_TR3;         //Trigger Timer3
 298   1                  clr_IE_ES;
 299   1      }
 300          
 301          
 302          void INT0_ISR(void) interrupt 0          // Vector @  0x03
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 6   

 303          {
 304   1        DISABLE_GLOBAL_INTERRUPT;
 305   1          _push_(SFRS);
 306   1        //emergency stop button function written
 307   1          PWM_Disable_int(2);
 308   1          PWM1_Disable_int(1);
 309   1          //Cart.Start = CYCLE_STOP;
 310   1            chart_status = CYCLE_STOP;
 311   1        
 312   1        // set all the satus regarding direction 
 313   1        // and emergency stop is detected then start cycle from previous memory status
 314   1          clr_TCON_IE0;
 315   1          _pop_(SFRS);
 316   1        ENABLE_GLOBAL_INTERRUPT;
 317   1      }
 318          
 319          void Pin_INT_ISR(void) interrupt 7       // Vector @  0x3B
 320          {
 321   1        unsigned char temp;
 322   1        DISABLE_GLOBAL_INTERRUPT;
 323   1        _push_(SFRS);
 324   1        temp = PIF;
 325   1        if(temp&SET_BIT0)
 326   1        {
 327   2          // proxy 1 Sensor Detection
 328   2          //if(Cart.Start == CYCLE_ON)
 329   2            if(chart_status == CYCLE_ON)
 330   2          {
 331   3          Cart.Start_Sensor = 1;
 332   3          }
 333   2        }
 334   1        
 335   1        temp = PIF;
 336   1        if(temp&SET_BIT1)
 337   1        {
 338   2          //if(Cart.Start == CYCLE_ON)
 339   2            if(chart_status == CYCLE_ON)
 340   2          {
 341   3           // proxy 2 Sensor Detection
 342   3          Cart.End_Sensor = 1;
 343   3          }
 344   2            
 345   2        }
 346   1        
 347   1        temp = PIF;
 348   1        if(temp&SET_BIT2)
 349   1        {
 350   2          // switch 2 action defination start button cycle
 351   2          if(Cart.Start != CYCLE_ON)
 352   2          {
 353   3            if(Cart.Direction == FORWORD)
 354   3            {
 355   4              Forword_Dir;
 356   4              //Cart.Direction = FORWORD;
 357   4            }
 358   3            {
 359   4              Reverse_Dir;
 360   4              //Cart.Direction = REVERSE;
 361   4            }
 362   3            PWM_Enable_int(2,MOTOR_SPEED,PWM0_Periode);
 363   3            //Cart.Start = 0x0  CYCLE_ON;
 364   3            chart_status = 0x00;
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 7   

 365   3            Pump_status = ON; // manual checking status of pump cleared when pump status is on
 366   3            PWM1_Enable_int(1,PUMP_SPEED,PWM1_Periode);
 367   3          }
 368   2        }
 369   1        
 370   1        temp = PIF;
 371   1        if(temp&SET_BIT3)
 372   1        {
 373   2          if(Pump_status != ON)
 374   2          {
 375   3            PWM1_Enable_int(1,PUMP_SPEED,PWM1_Periode);
 376   3            Pump_status = ON;
 377   3          }
 378   2          
 379   2          else
 380   2          {
 381   3            PWM1_Disable_int(1);
 382   3            Pump_status = OFF;
 383   3          }
 384   2          
 385   2          // switch 3 action defination   pump start stop manully 
 386   2        }
 387   1           PIF = 0x00;
 388   1          _pop_(SFRS);
 389   1        ENABLE_GLOBAL_INTERRUPT;
 390   1      }
 391          
 392          
 393          
 394          void Capture_ISR(void) interrupt 12      // Vector @  0x63
 395          {
 396   1        unsigned char temp;
 397   1        DISABLE_GLOBAL_INTERRUPT;
 398   1          _push_(SFRS);
 399   1            SFRS=0;
 400   1        temp = CAPCON0;
 401   1        if(temp&SET_BIT0)
 402   1        {
 403   2          if(Sensor_1 == TRIGGERED)
 404   2          {
 405   3            Sensor_1 = CAPTURED;
 406   3            C0L = 0x00;
 407   3            C0H = 0x00;
 408   3          }
 409   2          if(Sensor_1 == CAPTURED)
 410   2          {
 411   3            Sensor_1 = COMPLETE;
 412   3            clr_T2CON_TR2; // stope the timer2 from counting
 413   3          }
 414   2        }
 415   1        temp = CAPCON0;
 416   1        if(temp&SET_BIT1)
 417   1        {
 418   2          if(Sensor_2 == TRIGGERED)
 419   2          {
 420   3            Sensor_2 = CAPTURED;
 421   3            C0L = 0x00;
 422   3            C0H = 0x00;
 423   3          }
 424   2          if(Sensor_2 == CAPTURED)
 425   2          {
 426   3            Sensor_2 = COMPLETE;
C51 COMPILER V9.60.0.0   MAIN                                                              09/05/2021 23:55:20 PAGE 8   

 427   3            clr_T2CON_TR2; // stope the timer2 from counting
 428   3          }
 429   2        }
 430   1          clr_CAPCON0_CAPF0;
 431   1          clr_CAPCON0_CAPF1;
 432   1          _pop_(SFRS);
 433   1        ENABLE_GLOBAL_INTERRUPT;
 434   1      }
 435          
 436          void Timer1_ISR(void) interrupt 3        // Vector @  0x1B
 437          {
 438   1          _push_(SFRS);
 439   1         clr_TCON_TF1;
 440   1          _pop_(SFRS);
 441   1          _pop_(SFRS);
 442   1      }
 443          
 444          
 445          void WKT_ISR(void) interrupt 17                 // Vector @  0x8B
 446          {
 447   1          _push_(SFRS);
 448   1          clr_WKCON_WKTF;
 449   1          _pop_(SFRS);
 450   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1775    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     35       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
